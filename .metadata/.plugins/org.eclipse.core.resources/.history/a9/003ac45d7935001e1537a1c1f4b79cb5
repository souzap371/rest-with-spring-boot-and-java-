package br.ufrn.imd.solicitacaurn.mkdata.controller;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.time.LocalDate;
import java.time.Period;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import br.com.mkapi.exception.ApiException;
import br.com.mkapi.firebase.domain.PushNotificationRequest;
import br.com.mkapi.mkdata.domain.Agendas;
import br.com.mkapi.mkdata.domain.TiposAgendamento;
import br.com.mkapi.mkdata.repository.AgendasRepositoryMkdata;
import br.com.mkapi.mkdata.repository.PacienteRepositoryMkdata;
import br.com.mkapi.mkdata.repository.SituacaoRepositoryMkdata;
import br.com.mkapi.mkdata.repository.TipoAgendamentoRepository;
import br.com.mkapi.service.PushNotificationService;
import br.com.mkapi.solus.domain.BeneficiarioSolus;
import br.com.mkapi.solus.domain.EspecialidadeNotificacaoDesativada;
import br.com.mkapi.solus.domain.NotificacaoSolus;
import br.com.mkapi.solus.domain.RegraAgendamento;
import br.com.mkapi.solus.domain.UsuarioSolusAppMob;
import br.com.mkapi.solus.domain.enums.TipoSolicitacao;
import br.com.mkapi.solus.domain.enums.TipoUsuario;
import br.com.mkapi.solus.repository.BeneficiarioSolusRepository;
import br.com.mkapi.solus.repository.EspecialidadeNotificacaoDesativadaRepository;
import br.com.mkapi.solus.repository.NotificacaoSolusRepository;
import br.com.mkapi.solus.repository.RegraAgendamentoRepository;
import br.com.mkapi.solus.repository.UsuarioSolusAppMobRepository;

/*
 * Fluxo principal de controle de agendamentos.
 */

@Controller
@RequestMapping("/api/mkdata/agendas")
@CrossOrigin(origins = "*", allowedHeaders = "*")
public class AgendasControllerMkdata {
	@Autowired
	AgendasRepositoryMkdata agendasRepository;
	
	@Autowired
	PacienteRepositoryMkdata pacienteRepository;
	
	@Autowired
	SituacaoRepositoryMkdata situacaoRepository;
	
	@Autowired
	UsuarioSolusAppMobRepository usuarioRepository;
	
	@Autowired
	private BeneficiarioSolusRepository beneficiarioSolusRepository;
	
	@Autowired
	private PushNotificationService pushNotificationService;
	
	
	@Autowired
	private NotificacaoSolusRepository notificacaoRepository;
	
	@Autowired
	private TipoAgendamentoRepository tipoAgendamentoRepository;

	@Autowired
	private RegraAgendamentoRepository regraAgendamentoRepository;	
	
	@Autowired
	private EspecialidadeNotificacaoDesativadaRepository especialidadeNotificacaoDesativadaRepository;
	
	@GetMapping("/getAgendasDisponiveis/{idMedico}/{idEspecialidade}/{idConsultorio}")
	public ResponseEntity<List<Agendas>> getAgendasDisponiveis(@PathVariable("idMedico") Long id, 
			@PathVariable("idEspecialidade") Long idEspecialidade, 
			@PathVariable Long idConsultorio) {
		List<Agendas> agendas = agendasRepository.getAgendasDisponiveis(id, idConsultorio, idEspecialidade);
		return new ResponseEntity<>(agendas, HttpStatus.OK);
	}

	@GetMapping("/getAgendasByPaciente/{idSolus}")
	public ResponseEntity<?> getAgendasByPaciente(@PathVariable("idSolus") Long idSolus) {
		UsuarioSolusAppMob usuario = usuarioRepository.findByIdSolus(idSolus);
		Optional<BeneficiarioSolus> optBeneficiario = beneficiarioSolusRepository.findById(idSolus);

		BeneficiarioSolus beneficiario;
		if(optBeneficiario.isPresent()){
			beneficiario = optBeneficiario.get();
		} else {
			return new ResponseEntity<>("Beneficiário não encontrado", HttpStatus.FORBIDDEN);
		}

		List<Agendas> agendas;
		
		try {
			if(usuario.getTipoUsuario().equals(TipoUsuario.TITULAR)) {
				List<String> familiaCodigoBeneficiarioList = beneficiarioSolusRepository.findCodigoBeneficiarioByCpfTitular(beneficiario.getCpfTitular());
				
				agendas = agendasRepository.getAgendasByFamilia(familiaCodigoBeneficiarioList);
			} else {
				agendas = agendasRepository.getAgendasByPacienteAndCodigoBeneficiario(beneficiario.getCodigoBeneficiario());
				
			}
			return new ResponseEntity<>(agendas, HttpStatus.OK);
		}
		catch (ApiException e) {
			return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}
	
	@GetMapping("/getAgendaByID/{id}")
	public ResponseEntity<Agendas> getAgendasById(@PathVariable("id") Long id) {

		Agendas agenda = agendasRepository.findById(id).get();

		if(agenda == null){
			return new ResponseEntity<>(HttpStatus.NOT_FOUND);
		}else{
			return new ResponseEntity<>(agenda, HttpStatus.OK);
		}
	}
	
	@PostMapping("/marcarAgendamento/{idAgenda}/{idSolus}")
	public ResponseEntity<String> marcarAgendamento(@PathVariable("idAgenda") Long id, @PathVariable("idSolus") Long idSolus) {
		Agendas agenda = agendasRepository.findById(id).get();

		Optional<BeneficiarioSolus> optBeneficiario = beneficiarioSolusRepository.findById(idSolus);
		BeneficiarioSolus beneficiario;
		if(optBeneficiario.isPresent()){
			beneficiario = optBeneficiario.get();
		} else{
			return new ResponseEntity<>("Beneficiário não encontrado.", HttpStatus.FORBIDDEN);
		}		

		List<Agendas> agendasPaciente = agendasRepository.getAgendasByPacienteAndCodigoBeneficiarioNaoCanceladas(beneficiario.getCodigoBeneficiario());		

		//Verificação das regras de agendamento, em relação à idade do paciente.
		UsuarioSolusAppMob u = usuarioRepository.findByIdSolus(idSolus);
		List<RegraAgendamento> regrasAgenda = regraAgendamentoRepository.getRegraByMedicoAndEspecialidade(agenda.getMedico().getId(), agenda.getEspecialidade().getId());
		
		if(regrasAgenda != null && regrasAgenda.size() > 0 && u != null && u.getDataNascimento() != null){ 
			int idadePaciente = Period.between(Instant.ofEpochMilli(u.getDataNascimento().getTime()).atZone(ZoneId.systemDefault()).toLocalDate(), LocalDate.now()).getYears();  

			for(RegraAgendamento ra : regrasAgenda){
				if(ra.getPacienteIdadeMin() != null && idadePaciente < ra.getPacienteIdadeMin()){
					return new ResponseEntity<>("O agendamento não pode ser realizado, pois o médico atende pacientes com pelo menos " + ra.getPacienteIdadeMin() + " anos nesta especialidade.", HttpStatus.FORBIDDEN);
				}

				if(ra.getPacienteIdadeMax() != null && idadePaciente > ra.getPacienteIdadeMax()){
					return new ResponseEntity<>("O agendamento não pode ser realizado, pois o médico atende pacientes com até " + ra.getPacienteIdadeMax() + " anos nesta especialidade.", HttpStatus.FORBIDDEN);
				}
			}
		}

		Date dataAMarcar = agenda.getDataAgenda();
		Instant instantAntes = Instant.ofEpochMilli(dataAMarcar.getTime()).minusSeconds(2592000);
		Instant instantDepois = Instant.ofEpochMilli(dataAMarcar.getTime()).plusSeconds(2592000);
		Date data30DiasAntes = Date.from(instantAntes);
		Date data30DiasDepois = Date.from(instantDepois);
		
		//critérios de agendamento - nao pode na mesma data para o mesmo medico ou a mesma especialidade
		for(int i = 0; i < agendasPaciente.size(); i++){

			if(agendasPaciente.get(i).getDataAgenda().after(data30DiasAntes) && agendasPaciente.get(i).getEspecialidade().getId() == agenda.getEspecialidade().getId()){
				String dataFormatada = new SimpleDateFormat("dd/MM/yyyy").format(agendasPaciente.get(i).getDataAgenda());
				return new ResponseEntity<>("O prazo de uma consulta para uma mesma especialidade é de 30 dias.\n"+
				"Você já tem uma consulta agendada em: "+dataFormatada, HttpStatus.FORBIDDEN);
			}
			else if(agendasPaciente.get(i).getDataAgenda().after(data30DiasAntes) && agendasPaciente.get(i).getMedico().getId() == agenda.getMedico().getId()){
				
				String dataFormatada = new SimpleDateFormat("dd/MM/yyyy").format(agendasPaciente.get(i).getDataAgenda());
				return new ResponseEntity<>("O prazo de uma consulta para o(a) mesmo(a) médico(a) é de 30 dias. \n"+
				"Você já tem uma consulta agendada em: "+dataFormatada, HttpStatus.FORBIDDEN);
			}
			else if(agendasPaciente.get(i).getDataAgenda().before(data30DiasDepois) && agendasPaciente.get(i).getDataAgenda().after(dataAMarcar) && agendasPaciente.get(i).getEspecialidade().getId() == agenda.getEspecialidade().getId()){


				String dataFormatada = new SimpleDateFormat("dd/MM/yyyy").format(agendasPaciente.get(i).getDataAgenda());
				return new ResponseEntity<>("O prazo de uma consulta para uma mesma especialidade é de 30 dias.\n"+
				"Você já tem uma consulta agendada em: "+dataFormatada, HttpStatus.FORBIDDEN);
			}
			else if(agendasPaciente.get(i).getDataAgenda().before(data30DiasDepois) && agendasPaciente.get(i).getDataAgenda().after(dataAMarcar) && agendasPaciente.get(i).getMedico().getId() == agenda.getMedico().getId()){
				String dataFormatada = new SimpleDateFormat("dd/MM/yyyy").format(agendasPaciente.get(i).getDataAgenda());
				return new ResponseEntity<>("O prazo de uma consulta para o(a) mesmo(a) médico(a) é de 30 dias. \n"+
				"Você já tem uma consulta agendada em: "+dataFormatada, HttpStatus.FORBIDDEN);
			}
		}

		agenda.setPaciente(pacienteRepository.getIdPacienteByCodigoBeneficiario(beneficiario.getCodigoBeneficiario()));
		//não permite que o agendamento seja marcado sem paciente
		if(agenda.getPaciente() == null){
			return new ResponseEntity<>("Paciente não encontrado.", HttpStatus.FORBIDDEN);
		}

		System.out.println("\nAGENDAMENTO VERIFICADO\n");

		agenda.setSituacao(situacaoRepository.findById(Long.valueOf(3)).get());
		//encontrar o tipo do agendamento
		//tipo do agendamento pela consulta da especialidade e pelo id do consultório
		TiposAgendamento tipoAgendamento = tipoAgendamentoRepository.getTipoAgendamentoByConsultorioAndEspecialidade( 
				agenda.getEspecialidade().getTipoConsulta().getNome(),
				agenda.getConsultorio().getId());
		//caso não encontre, filtra apenas pelo consultório
		if(Objects.isNull(tipoAgendamento)) {
			tipoAgendamento = tipoAgendamentoRepository.getTipoAgendamentoByConsultorio(
					agenda.getConsultorio().getId());
		}
		agenda.setTipoAgendamento(tipoAgendamento);
		agenda.setConvenioId(1);
		agenda.setDtAgendamento(new Date());
		agenda.setAgMobile(true);
		agendasRepository.save(agenda);

		return new ResponseEntity<>("O Agendamento foi marcado com sucesso.", HttpStatus.OK);
	}	
	
	@GetMapping("/{idAgendamento}/confirmarMkdata")
	public ResponseEntity<?> confirmarAgendamentoMkdata(@PathVariable("idAgendamento") Long idAgendamento){
		Agendas agendamento = agendasRepository.findById(idAgendamento).get();

		List<String> carteiras = pacienteRepository.getCodigoBeneficiarioByIdPaciente(agendamento.getPaciente().getId());
		String codigoCarteira = "";

		if(carteiras.size() > 1){
			for(String s : carteiras){
				if(beneficiarioSolusRepository.findByNumcarteira(s).isPresent()){
					codigoCarteira = s;
					break;
				}
			}
		} else if(carteiras.isEmpty()){
			return new ResponseEntity<>("Paciente não encontrado.", HttpStatus.FORBIDDEN);
		} else{
			codigoCarteira = carteiras.get(0);
		}

		Optional<UsuarioSolusAppMob> optUsuario = usuarioRepository.findByCodigoBeneficiario(codigoCarteira);
		UsuarioSolusAppMob u;
		if(optUsuario.isPresent()){
			u = optUsuario.get();
		} else{
			return new ResponseEntity<>("Usuário não encontrado.", HttpStatus.FORBIDDEN);
		}

		agendamento.setSituacao(situacaoRepository.findById(Long.valueOf(8)).get());
		agendasRepository.save(agendamento);
		DateFormat dtf = new SimpleDateFormat("dd/MM/yyyy");

		List<EspecialidadeNotificacaoDesativada> especialidades = especialidadeNotificacaoDesativadaRepository.findAll();
		List<Long> ids = especialidades.stream().map(e -> e.getIdEspecialidade()).collect(Collectors.toList());

		//Envio de notificação para o usuário apenas se a especialidade não estiver com as notificações desativadas.
		if(!Objects.isNull(u) && !ids.contains(agendamento.getEspecialidade().getId())) {
			PushNotificationRequest msg = new PushNotificationRequest();
			msg.setToken(u.getFirebaseToken());
			msg.setTitle("Agendamento confirmado");
			msg.setMessage("Foi confirmado o agendamento para "+dtf.format(agendamento.getDataAgenda()) +" às " +
			agendamento.getHoraInicio() +" referente ao beneficiário: "+ agendamento.getPaciente().getNome());
			msg.setTipoSolicitacao(TipoSolicitacao.AGENDAMENTO);
			msg.setIdSolicitacao(String.valueOf(agendamento.getId()));
			msg.setIdUsuario(u.getId());
			
			if(!Objects.isNull(u.getFirebaseToken()))
				pushNotificationService.sendPushNotificationToToken(msg);
			
			notificacaoRepository.save(new NotificacaoSolus(msg, u));
		}
		return new ResponseEntity<>(agendamento,HttpStatus.OK);
	}

	@GetMapping("/{idAgendamento}/cancelarMkdata")
	public ResponseEntity<?> cancelarAgendamentoMkdata(@PathVariable("idAgendamento") Long idAgendamento){
		Agendas agendamento = agendasRepository.findById(idAgendamento).get();

		List<String> carteiras = pacienteRepository.getCodigoBeneficiarioByIdPaciente(agendamento.getPaciente().getId());
		String codigoCarteira = "";

		if(carteiras.size() > 1){
			for(String s : carteiras){
				if(beneficiarioSolusRepository.findByNumcarteira(s).isPresent()){
					codigoCarteira = s;
					break;
				}
			}
		} else if(carteiras.isEmpty()){
			return new ResponseEntity<>("Paciente não encontrado.", HttpStatus.FORBIDDEN);
		} else{
			codigoCarteira = carteiras.get(0);
		}

		Optional<UsuarioSolusAppMob> optUsuario = usuarioRepository.findByCodigoBeneficiario(codigoCarteira);
		UsuarioSolusAppMob u;
		if(optUsuario.isPresent()){
			u = optUsuario.get();
		} else{
			return new ResponseEntity<>("Usuário não encontrado.", HttpStatus.FORBIDDEN);
		}

		/* CRIAR NOVO REGISTRO NA TABELA DE AGENDAS, COM AS INFORMAÇÕES DO AGENDAMENTO CANCELADO */

		DateFormat df = new SimpleDateFormat("yyyy-MM-dd");		
		Integer quantidadeAgendasCanceladas = agendasRepository.getCountAgendasCanceladasByHorario(
			agendamento.getMedico().getId(), 
			agendamento.getConsultorio().getId(), 
			agendamento.getEspecialidade().getId(), 
			df.format(agendamento.getDataAgenda()),
			agendamento.getHoraInicio(),
			agendamento.getHoraFim());

		Agendas novaAgenda = new Agendas();
		novaAgenda.setModuloId(agendamento.getModuloId());
		novaAgenda.setEspecialidade(agendamento.getEspecialidade());
		novaAgenda.setConsultorio(agendamento.getConsultorio());
		novaAgenda.setSituacao(situacaoRepository.findById(Long.valueOf(5)).get());
		novaAgenda.setUsuarioCriaId(agendamento.getUsuarioCriaId());
		novaAgenda.setDataAgenda(agendamento.getDataAgenda());
		novaAgenda.setHoraInicio(agendamento.getHoraInicio().substring(0, 4) + (quantidadeAgendasCanceladas + 1) + ":00"); //incrementar horário da agenda cancelada
		novaAgenda.setHoraFim(agendamento.getHoraFim());
		novaAgenda.setEncaixe(agendamento.getEncaixe());
		novaAgenda.setRetorno(agendamento.getRetorno());
		novaAgenda.setAutorizado(agendamento.getAutorizado());
		novaAgenda.setIntercambio(agendamento.getIntercambio());
		novaAgenda.setRecemNascido(agendamento.getRecemNascido());
		novaAgenda.setMedico(agendamento.getMedico());
		novaAgenda.setMonitorado(agendamento.getMonitorado());
		novaAgenda.setConvenioId(agendamento.getConvenioId());
		novaAgenda.setAgCentral(agendamento.getAgCentral());
		novaAgenda.setModalidade(agendamento.getModalidade());
		novaAgenda.setOrdemUra(1L);
		novaAgenda.setStatusUra(agendamento.getStatusUra());
		novaAgenda.setConsorigemId(agendamento.getConsorigemId());
		novaAgenda.setAps(agendamento.getAps());
		novaAgenda.setAguardarPend(agendamento.getAguardarPend());
		novaAgenda.setAgOnline(agendamento.getAgOnline());
		novaAgenda.setPassouCartaoPres(agendamento.getPassouCartaoPres());
		novaAgenda.setValidouBioPres(agendamento.getValidouBioPres());
		novaAgenda.setConsultaway(agendamento.getConsultaway());
		novaAgenda.setDispMobile(agendamento.getDispMobile());		
		novaAgenda.setPassouQrcodePres(agendamento.getPassouQrcodePres());
		novaAgenda.setTipoAgendamento(agendamento.getTipoAgendamento());
		novaAgenda.setConvenioId(agendamento.getConvenioId());
		novaAgenda.setDtAgendamento(agendamento.getDtAgendamento());
		novaAgenda.setPaciente(agendamento.getPaciente());
		if(agendamento.getAgMobile() != null){
			novaAgenda.setAgMobile(agendamento.getAgMobile().equals("S"));
		}

		novaAgenda = agendasRepository.save(novaAgenda);

		/* LIMPAR DADOS DO AGENDAMENTO CANCELADO, LIBERANDO O HORÁRIO PARA NOVOS AGENDAMENTOS */		

		agendamento.setTipoAgendamento(null);
		agendamento.setConvenioId(1);
		agendamento.setDtAgendamento(null);
		agendamento.setAgMobile(false);
		agendamento.setOrdemUra(null);
		agendamento.setPaciente(null);
		agendamento.setSituacao(situacaoRepository.findById(Long.valueOf(1)).get());
		agendasRepository.save(agendamento);

		DateFormat dtf = new SimpleDateFormat("dd/MM/yyyy");

		List<EspecialidadeNotificacaoDesativada> especialidades = especialidadeNotificacaoDesativadaRepository.findAll();
		List<Long> ids = especialidades.stream().map(e -> e.getIdEspecialidade()).collect(Collectors.toList());

		//Envio de notificação para o usuário apenas se a especialidade não estiver com as notificações desativadas.
		if(!Objects.isNull(u) && !ids.contains(novaAgenda.getEspecialidade().getId())) {
			PushNotificationRequest msg = new PushNotificationRequest();
			msg.setToken(u.getFirebaseToken());
			msg.setTitle("Agendamento cancelado");
			msg.setMessage("Foi cancelado o agendamento para "+dtf.format(novaAgenda.getDataAgenda()) +" às " +
			agendamento.getHoraInicio() +" referente ao beneficiário: "+ novaAgenda.getPaciente().getNome());
			msg.setTipoSolicitacao(TipoSolicitacao.AGENDAMENTO);
			msg.setIdSolicitacao(String.valueOf(novaAgenda.getId()));
			msg.setIdUsuario(u.getId());
			
			if(!Objects.isNull(u.getFirebaseToken()))
				pushNotificationService.sendPushNotificationToToken(msg);
			
			notificacaoRepository.save(new NotificacaoSolus(msg, u));
		}
		return new ResponseEntity<>(agendamento,HttpStatus.OK);
	}
}
